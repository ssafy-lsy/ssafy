### 델타
![alt text](image.png)

```python
arr = [
    [1, 2, 1, 3, 1],
    [2, 2, 2, 2, 2],
    [1, 0, 1, 0, 1],
    [3, 1, 2, 1, 3]
]
y = 1
x = 2
sum_v = 0
# sum_v += arr[y-1][x+0] # 위
# sum_v += arr[y+1][x+0] # 아래
# sum_v += arr[y+0][x+1] # 오른쪽
# sum_v += arr[y+0][x-1] # 왼쪽

# print(sum_v)

# 상하좌우 방향배열 자료구조
# d : direction의 약자
dy = [-1, 1, 0, 0]
dx = [0, 0, -1, 1]

# 방향이 4방향
# ny : next y, y : 현재좌표 , dy : 방향배열
for i in range(4):
    ny = y + dy[i] # next y, x
    nx = x + dx[i] # 위, 아래, 오른쪽, 왼쪽
    sum_v += arr[ny][nx]

print(sum_v)
```

![alt text](image-1.png)

```python
arr = [
    [1, 2, 1, 3, 1],
    [2, 2, 2, 2, 2],
    [1, 0, 1, 0, 1],
    [3, 1, 2, 1, 3]
]
y = 0
x = 1
sum_v = 0
# sum_v += arr[y-1][x+0] # 위
# sum_v += arr[y+1][x+0] # 아래
# sum_v += arr[y+0][x+1] # 오른쪽
# sum_v += arr[y+0][x-1] # 왼쪽

# print(sum_v)

# 상하좌우 방향배열 자료구조
# d : direction의 약자
dy = [-1, 1, 0, 0]
dx = [0, 0, -1, 1]

# 방향이 4방향
# ny : next y, y : 현재좌표 , dy : 방향배열
for i in range(4):
    ny = y + dy[i] # next y, x
    nx = x + dx[i] # 위, 아래, 오른쪽, 왼쪽

    # 첫 번째 코드
    # if 0 <= ny < 4 and 0 <= nx < 5:
    #     sum_v += arr[ny][nx]

    # 두 번째 코드
    # 범위를 벗어나면 sum_v를 계산하지않고 반복문 처음으로 돌아간다 -> continue
    if ny < 0 or ny >= 4 or nx < 0 or nx >= 5: continue
    sum_v += arr[ny][nx]
    # 들여쓰기를 하나라도 줄여준다.
    # 가독성이 좋은 코드

print(sum_v)

```

### boss 문제 - 폭탄 투하(난이도 low)
```python
arr = [['_'] * 5 for _ in range(4)] # 4행 5열 '_'채워진 2차원 배열
for _ in range(2): # 폭탄 2개
    y, x = map(int, input().split())
    dy = [-1, -1, -1, 0, 1, 1, 1, 0]
    dx = [-1, 0, 1, 1, 1, 0, -1, -1]
    for i in range(8): # 8방향
        ny = y + dy[i]
        nx = x + dx[i]
        if ny < 0 or ny >= 4 or nx < 0 or nx >= 5: continue
        arr[ny][nx] = '#'

for row in arr: # iterator방식으로 순회
    print(*row)

```

### 차르봄바
``` python
def get_sum(y, x):
    dy = [-1, 1, 0, 0] # 4방향(상하좌우)
    dx = [0, 0, -1, 1]
    sum_v = arr[y][x] # 초기화 (현재위치) (핵심 : 한번만 더해야된다)
    for i in range(4): # 4방향
        for k in range(1, P + 1):
            ny, nx = y + dy[i] * k, x + dx[i] * k
            if ny < 0 or ny >= N or nx < 0 or nx >= N: continue
            sum_v += arr[ny][nx] # 현재위치 + 4방향의 값 누적

    return sum_v

T = int(input())
for tc in range(1, T + 1):
    result = float('-inf')
    N, P = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]
    for y in range(N): # 행순회
        for x in range(N):
            result = max(result, get_sum(y, x)) # 함수호출

    print(f'#{tc} {result}')
```

### 폭탄 터뜨리기
``` python

```